<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="author" content="">

<title>New HMTL document by NewJect</title>
</head>
<body>
<p>键盘方向键控制</p>
<div>
    <canvas id="myCanvas" width="" height="">
      your browser doesn't support canvas!
    </canvas>
</div>
<script>
    var FPS=60;
//    预载贴图
    var image={
        npc:[],
        background:[]        
    }   
    image.npc[0]=new Image();
    image.npc[1]=new Image();
    image.npc[0].src="./img/角色停顿图.png";
    image.npc[1].src="./img/角色行走图.png";
    image.background[0]=new Image();
    image.background[1]=new Image();
    image.background[100]=new Image();
    image.background[101]=new Image();
    image.background[102]=new Image();
    image.background[0].src="./img/001草地.png";
    image.background[1].src="./img/002地砖.png";
    image.background[100].src="./img/100红树.png";
    image.background[101].src="./img/101绿树.png";
    image.background[102].src="./img/102高绿树.png";
    
//    创建画布并设置画布宽高
    var canvas=document.getElementById('myCanvas');
//    var C_width =(document.documentElement.clientWidth)*(0.95);
//    var C_height =(document.documentElement.clientHeight)*(0.95);
    var C_width =800;
    var C_height =500;
    canvas.width = C_width;
    canvas.height = C_height;
    var context = canvas.getContext('2d');
//    状态组
    var state={
        image_load:false,
        map_load:false,
//        步行和跑动判断
        Stand:false,
//        运动方向
        run_up:false,
        run_down:false,
        run_left:false,
        run_right:false,
//        npc朝向
        npc1_dire:0,
//        npc运动状态
        npc1_state:0,
        npc1_x:parseInt(C_width/2),
        npc1_y:parseInt(C_height/2),
//        地图偏移量
        map_x:0,
        map_y:0,
//        地图偏移速率
        map_speed:1.5,
//        地图数据
        maps:{},
    }
//    线程组
    var time={
//        画面绘制
        draw:setInterval(function(){
            context.clearRect(0,0,C_width,C_height);
            if(state.image_load==true&&map_load==true){
                draw_map();
                draw_npc();
            }                
        },1000/FPS),
//        人物状态判断线程
        npc_move:setInterval(function(){
            if(state.run_up==true){
                state.npc1_dire=3;
                if(state.npc1_state<3){
                    state.npc1_state++;
                }else{
                    state.npc1_state=0;
                }                
            }
            if(state.run_down==true){
                state.npc1_dire=0;
                if(state.npc1_state<3){
                    state.npc1_state++; 
                }else{                     
                    state.npc1_state=0;
                }                
            }
            if(state.run_left==true){
                state.npc1_dire=1;
                if(state.npc1_state<3){
                    state.npc1_state++;
                }else{
                    state.npc1_state=0;
                }                
            }
            if(state.run_right==true){
                state.npc1_dire=2;
                if(state.npc1_state<3){
                    state.npc1_state++;
                }else{
                    state.npc1_state=0;
                }                
            }
        },125),
//        地图偏移 碰撞检测
        map_move:setInterval(function(){
            var click={
                    x: parseInt((state.npc1_x-state.map_x+25)/50),
                    y: parseInt((state.npc1_y-state.map_y+25)/50),
                }
//            地图运动
            if(state.run_up==true){
                click.y=parseInt((state.npc1_y-state.map_y)/50);
                if(state.maps.decorate[click.x][click.y]>=100){
                    return;
                }else{
                    state.map_y=state.map_y+state.map_speed;
                }                
            }
            if(state.run_down==true){
                click.y=parseInt((state.npc1_y-state.map_y)/50);
                if(state.maps.decorate[click.x][click.y+1]>=100){
                    return;
                }else{
                state.map_y=state.map_y-state.map_speed;
                }
            }
            if(state.run_left==true){
                click.x=parseInt((state.npc1_x-state.map_x)/50);
                if(state.maps.decorate[click.x][click.y]>=100){
                    return;
                }else{
                state.map_x=state.map_x+state.map_speed;
                }
            }
            if(state.run_right==true){
                click.x=parseInt((state.npc1_x-state.map_x)/50);
                if(state.maps.decorate[click.x+1][click.y]>=100){
                    return;
                }else{
                state.map_x=state.map_x-state.map_speed;
                }
            }
        },1000/FPS),
    }    

    window.onload=function(){
        loadJson();        
        state.image_load=true; 
        state.Stand=true;
//        绑定按键
        window.onkeydown=function(){
            var keycode=this.event.keyCode;
            switch(keycode){
                case 38:state.Stand=false;state.run_up=true;break;
                case 40:state.Stand=false;state.run_down=true;break;
                case 37:state.Stand=false;state.run_left=true;break;
                case 39:state.Stand=false;state.run_right=true;break;
                default:break;
            }
        }
        window.onkeyup=function(){
            var keycode=this.event.keyCode;
            switch(keycode){
                case 38:state.Stand=true;state.run_up=false;break;
                case 40:state.Stand=true;state.run_down=false;break;
                case 37:state.Stand=true;state.run_left=false;break;
                case 39:state.Stand=true;state.run_right=false;break;
                default:break;
            }
        }        
//        test方法
//        canvas.onmousedown=function(e){
//        var e=e||window.Event;
//        var rect = canvas.getBoundingClientRect(); 
//        var coordinate={
//            x: e.clientX - rect.left * (canvas.width / rect.width), 
//            y: e.clientY - rect.top * (canvas.height / rect.height)  
//        }
//        var click={
//            x: parseInt((coordinate.x/50)-(state.map_x/50)),
//            y: parseInt((coordinate.y/50)-(state.map_y/50)),
//        }
//        var clicks={
//            x: parseInt((state.npc1_x-state.map_x+25)/50),
//            y: parseInt((state.npc1_y-state.map_y+25)/50),
//        }
//        console.log(clicks);
//        console.log(state.maps.decorate[clicks.x][clicks.y-1]);
//        console.log(state.maps.decorate[clicks.x][clicks.y+1]);
//        console.log(state.maps.decorate[clicks.x-1][clicks.y]);
//        console.log(state.maps.decorate[clicks.x+1][clicks.y]);
//            console.log("-----------");
//        console.log(click);
//        console.log(state.maps.decorate[click.x][click.y]);
//        
//        }
    }  
//    绘制地图
    function draw_map(x_map,y_map){  
        var x_map=x_map||0;
        var y_map=y_map||0;
        for(var i=0;i<40;i++){
            for(var y=0;y<40;y++){
                context.drawImage(image.background[state.maps.bg[i][y]],(i*50)+state.map_x,(y*50)+state.map_y);
            }        
        }
        for(var i=0;i<40;i++){
            for(var y=0;y<40;y++){
                if(state.maps.decorate[i][y]>=100){
                context.drawImage(image.background[state.maps.decorate[i][y]],(i*50)+state.map_x,(y*50)+state.map_y);
                }
            }        
        }        
    }
//    绘制npc
    function draw_npc(){
        if(state.Stand==true){
            context.drawImage(image.npc[0],(state.npc1_state*96),(state.npc1_dire*96),100,100,state.npc1_x,state.npc1_y,50,50);
        }else{
            context.drawImage(image.npc[1],(state.npc1_state*96),(state.npc1_dire*96),100,100,state.npc1_x,state.npc1_y,50,50);
        }
    }
    function npc_run(action){

    }
    
//    ajax读取地图数据
    function loadJson()
    {
	   var xmlhttp;
	   if(window.XMLHttpRequest)
        {xmlhttp=new XMLHttpRequest();}
        else
        {xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");}
       xmlhttp.open("get","map.json",true);
	   xmlhttp.send();
	   xmlhttp.onreadystatechange=function()
	   {
           if (xmlhttp.readyState==4 && xmlhttp.status==200)
           {            
                data=xmlhttp.responseText;               
                data=JSON.parse(data);
                state.maps=data;
                map_load=true;
            }
	   }
    }
    </script>
</body>
</html>